generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 Int                 @id @default(autoincrement())
  telegramId         BigInt              @unique
  username           String?
  firstName          String?
  lastName           String?
  name               String?             // Имя пользователя для настроек
  gender             String?             // Пол: 'male' | 'female'
  isIntroCompleted   Boolean             @default(false) // Флаг завершения вводного сценария
  introCompletedAt   DateTime?           // Дата завершения интро (для отсчета дней)
  password           String?             // Пароль для настроек
  timezone           String              @default("UTC") // Временная зона для утренних/вечерних сценариев
  nextMorningMessageAt DateTime?         // Время следующего утреннего напоминания (для "Напомнить позже" 2ч)
  nextEveningMessageAt DateTime?         // Время следующего вечернего напоминания (для "Напомнить позже" 2ч)
  lastPrincipleSentAt DateTime?          // Когда в последний раз отправляли принцип (для ограничения 1 принцип/день по локальной дате)
  subscriptionReminderAt DateTime?       // Время напоминания о подписке (через 2 дня после "Напомнить позже")
  skippedDays        Int                 @default(0) // Количество пропущенных дней (вечерняя рефлексия)
  currentPrincipleDay Int                @default(1) // Номер следующего принципа для отправки
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  
  subscription       Subscription?
  diaryEntries       DiaryEntry[]
  introductionData   IntroductionData?
  payments           Payment[]
  weeklyAnalytics    WeeklyAnalytics[]
  giftSubscriptionsCreated GiftSubscription[] @relation("GiftCreator")
  giftSubscriptionsRedeemed GiftSubscription[] @relation("GiftRedeemer")
  
  @@map("users")
}

model WeeklyAnalytics {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  weekNumber    Int      // Номер недели (1,2,3...) по циклам 7 дней
  dayNumber     Int      // Какой это день для пользователя в боте на момент аналитики
  notesDays     Int      // В скольких днях из 7 были заметки
  notesCount    Int      // Всего заметок за период
  period        Json     // Метаданные периода (например { startDay, endDay, principles: [...] })
  text          String   @db.Text
  createdAt     DateTime @default(now())

  @@unique([userId, weekNumber])
  @@index([userId, createdAt])
  @@map("weekly_analytics")
}

model GiftSubscription {
  id            Int      @id @default(autoincrement())
  token         String   @unique @default(cuid())
  status        String   @default("created") // created | paid | redeemed | cancelled
  planId        String
  days          Int
  amount        Int      // копейки
  currency      String   @default("RUB")
  createdAt     DateTime @default(now())
  paidAt        DateTime?
  redeemedAt    DateTime?
  // Кто купил
  createdByUserId Int
  createdBy      User     @relation("GiftCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)
  // Кто активировал (становится известен при редиме)
  redeemedByUserId Int?
  redeemedBy      User?    @relation("GiftRedeemer", fields: [redeemedByUserId], references: [id], onDelete: SetNull)

  @@index([createdByUserId, createdAt])
  @@index([redeemedByUserId, redeemedAt])
  @@map("gift_subscriptions")
}

model Subscription {
  id                Int      @id @default(autoincrement())
  userId            Int      @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  isActive          Boolean  @default(false)
  activatedAt       DateTime?
  trialDaysUsed     Int      @default(0) // Для отслеживания 7-дневного триала
  expiresAt         DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("subscriptions")
}

model DiaryEntry {
  id                Int      @id @default(autoincrement())
  userId            Int
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  dayNumber         Int      // Номер дня/принципа
  type              String   @default("general") // 'morning', 'evening', 'general'
  note              String   @db.Text
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("diary_entries")
  @@index([userId, dayNumber])
}

model TransurfingPrinciple {
  id          Int      @id @default(autoincrement())
  dayNumber   Int      @unique // Порядковый номер дня (1, 2, 3...)
  title       String
  declaration String   @db.Text // Текст декларации
  description String   @db.Text // Пояснение
  task        String   @db.Text // Задание "Сегодня наблюдай..."
  imageUrl    String?  // Опционально картинка
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("principles")
}

model IntroductionData {
  id                Int      @id @default(autoincrement())
  userId            Int      @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  data              Json     // Данные из вводного сценария
  completed         Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("introduction_data")
}

model BotMessage {
  id                Int      @id @default(autoincrement())
  key               String   @unique // Ключ для идентификации сообщения (например, "welcome_message", "menu_settings")
  text              String   @db.Text
  category          String   @default("general") // Категория: general, menu, introduction, daily, subscription
  description       String?  @db.Text // Описание для админки
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("bot_messages")
}

model Settings {
  id                Int      @id @default(autoincrement())
  key               String   @unique
  value             String   @db.Text
  description       String?  @db.Text
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("settings")
}

model Payment {
  id          Int      @id @default(autoincrement())
  uuid        String   @unique // Tribute Order UUID
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amount      Int      // In minimum currency units (kopecks)
  currency    String
  status      String   // 'new', 'paid', 'canceled', 'failed'
  orderId     String?  // Internal order ID if needed
  planId      String   // 'sub_plan_week', 'sub_plan_month', etc.
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("payments")
}

model Broadcast {
  id                 Int      @id @default(autoincrement())
  audience           String   // all | intro_not_completed | paid_active | no_paid_active
  text               String   @db.Text
  parseMode          String?  // 'HTML' | 'MarkdownV2' | null (plain)
  status             String   @default("pending") // pending | running | completed | cancelled | failed

  totalTargets       Int      @default(0)
  sentCount          Int      @default(0)
  failedCount        Int      @default(0)
  lastProcessedUserId Int?
  error              String?  @db.Text

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  startedAt          DateTime?
  finishedAt         DateTime?
  cancelledAt        DateTime?

  @@index([status, createdAt])
  @@map("broadcasts")
}
